<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Snake++ — gra w JavaScript (HTML5 canvas)</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#10b981;--muted:#94a3b8;--danger:#ef4444}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#020617 0%, #071027 60%);color:#e6eef6}
    .container{width:min(980px,95vw);display:grid;grid-template-columns:1fr 360px;gap:20px;padding:24px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}
    .game-area{display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas{background:linear-gradient(180deg,#071127, #02101a);border-radius:8px;box-shadow:inset 0 0 40px rgba(0,0,0,0.6);width:100%;height:auto}
    .hud{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:var(--accent);cursor:pointer}
    .btn.secondary{color:var(--muted)}
    .panel{padding:16px;display:flex;flex-direction:column;gap:12px}
    h1{margin:0;font-size:20px}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;text-align:center}
    .small{font-size:12px;color:var(--muted)}
    .controls{display:flex;flex-direction:column;gap:8px}
    .credit{font-size:12px;color:var(--muted);text-align:center}
    @media(max-width:880px){.container{grid-template-columns:1fr;}.panel{order:2}}
  </style>
</head>
<body>
  <div class="container">
    <div class="card game-area">
      <div style="width:100%">
        <h1>Snake++</h1>
        <p class="small">Sterowanie: strzałki / WASD / na urządzeniach: przesunięcie palcem. Spacja = pauza.</p>
      </div>

      <canvas id="gameCanvas" width="720" height="540"></canvas>

      <div class="hud">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="btn secondary">Pauza</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
        <div style="min-width:10px"></div>
        <div class="small">Wynik: <strong id="score">0</strong></div>
        <div class="small">Poziom: <strong id="level">1</strong></div>
        <div class="small">Prędkość: <strong id="speed">1</strong></div>
      </div>

      <div class="credit small">Stworzono przez ChatGPT — jeśli chcesz modyfikacje, powiedz które elementy zmienić.</div>
    </div>

    <aside class="card panel">
      <div>
        <strong>Informacje i power-upy</strong>
        <p class="small">Zbieraj jedzenie, unikaj przeszkód. Co kilka punktów pojawiają się power-upy: <em>+punkty</em>, <em>spowolnienie</em>, <em>przyspieszenie</em>, <em>przenikanie</em> (przejście przez ściany przez krótki czas).</p>
      </div>

      <div class="stats">
        <div class="stat">Długość: <div id="length">3</div></div>
        <div class="stat">Najlepszy: <div id="best">0</div></div>
      </div>

      <div class="controls">
        <label class="small">Ustawienia gry</label>
        <div style="display:flex;gap:8px">
          <label class="small">Siatka:</label>
          <select id="gridSize">
            <option value="20">20</option>
            <option value="24">24</option>
            <option value="28">28</option>
            <option value="32" selected>32</option>
          </select>
        </div>
        <div style="display:flex;gap:8px;align-items:center"><input id="wrapToggle" type="checkbox"><label class="small">Przejście przez ściany (wrap)</label></div>
        <div style="display:flex;gap:8px;align-items:center"><input id="obstaclesToggle" type="checkbox" checked><label class="small">Przeszkody</label></div>

        <div style="display:flex;gap:8px;margin-top:6px">
          <button id="applyBtn" class="btn secondary">Zastosuj</button>
          <button id="downloadBtn" class="btn">Pobierz .html</button>
        </div>
      </div>

      <div>
        <strong>Instrukcja</strong>
        <ol class="small">
          <li>Start — zaczyna grę.</li>
          <li>Pauza — zatrzymuje akcję (spacja też pauzuje).</li>
          <li>Reset — restart poziomu.</li>
          <li>Na urządzeniach dotykowych przesuń palcem, aby zmienić kierunek.</li>
        </ol>
      </div>
    </aside>
  </div>

  <script>
  // Snake++ — single-file game
  (()=>{
    const canvas=document.getElementById('gameCanvas');
    const ctx=canvas.getContext('2d');
    let grid=32; // will be overwritten by select
    let cols=Math.floor(canvas.width/grid);
    let rows=Math.floor(canvas.height/grid);

    // DOM
    const startBtn=document.getElementById('startBtn');
    const pauseBtn=document.getElementById('pauseBtn');
    const resetBtn=document.getElementById('resetBtn');
    const scoreEl=document.getElementById('score');
    const levelEl=document.getElementById('level');
    const speedEl=document.getElementById('speed');
    const lengthEl=document.getElementById('length');
    const bestEl=document.getElementById('best');
    const gridSelect=document.getElementById('gridSize');
    const wrapToggle=document.getElementById('wrapToggle');
    const obstaclesToggle=document.getElementById('obstaclesToggle');
    const applyBtn=document.getElementById('applyBtn');
    const downloadBtn=document.getElementById('downloadBtn');

    // game state
    let snake,dir,food,powerUps,obstacles,score,level,speed,frames,paused,gameOver,bestScore;
    let tickInterval=null;

    function resetState(){
      grid=parseInt(gridSelect.value);
      cols=Math.floor(canvas.width/grid);
      rows=Math.floor(canvas.height/grid);
      snake=[{x:Math.floor(cols/2),y:Math.floor(rows/2)},{x:Math.floor(cols/2)-1,y:Math.floor(rows/2)},{x:Math.floor(cols/2)-2,y:Math.floor(rows/2)}];
      dir={x:1,y:0};
      placeFood();
      powerUps=[];
      obstacles=[];
      score=0;level=1;speed=6;frames=0;paused=false;gameOver=false;
      bestScore=parseInt(localStorage.getItem('snakepp_best')||'0');
      updateHUD();
      generateObstacles();
    }

    function placeFood(){
      food=randomEmptyCell();
    }

    function randomEmptyCell(){
      for(let i=0;i<200;i++){
        const pos={x:rand(0,cols-1),y:rand(0,rows-1)};
        if(!snake.some(s=>s.x===pos.x && s.y===pos.y) && !obstacles.some(o=>o.x===pos.x && o.y===pos.y)) return pos;
      }
      // fallback
      return {x:0,y:0};
    }

    function rand(a,b){return Math.floor(Math.random()*(b-a+1))+a}

    function generateObstacles(){
      obstacles=[];
      if(!obstaclesToggle.checked) return;
      const count=Math.floor((cols*rows)/120);
      for(let i=0;i<count;i++){
        const o=randomEmptyCell();obstacles.push(o);
      }
    }

    function spawnPowerUp(){
      const types=['score','slow','fast','ghost'];
      powerUps.push({type:types[rand(0,types.length-1)],pos:randomEmptyCell(),ttl:800});
    }

    function update(){
      if(paused || gameOver) return;
      frames++;
      // movement tick
      if(frames % Math.max(1,Math.floor(60/speed)) === 0){
        const head={x:snake[0].x+dir.x,y:snake[0].y+dir.y};
        const wrap = wrapToggle.checked;
        if(wrap){
          head.x=(head.x+cols)%cols;head.y=(head.y+rows)%rows;
        }
        // collision with walls
        if(!wrap && (head.x<0 || head.x>=cols || head.y<0 || head.y>=rows)) return endGame();
        // collision with self
        if(snake.some((s,i)=>i>0 && s.x===head.x && s.y===head.y)) return endGame();
        // collision with obstacles
        if(obstacles.some(o=>o.x===head.x && o.y===head.y)) return endGame();

        snake.unshift(head);

        // eat food
        if(head.x===food.x && head.y===food.y){
          score+=10; maybeLevelUp(); placeFood();
          if(Math.random()<0.25) spawnPowerUp();
        } else {
          snake.pop();
        }

        // power-ups check
        for(let i=0;i<powerUps.length;i++){
          const p=powerUps[i];
          if(p.pos.x===head.x && p.pos.y===head.y){
            applyPowerUp(p.type);
            powerUps.splice(i,1);break;
          }
        }

        // tick power-up TTL
        powerUps.forEach(p=>p.ttl--);
        powerUps=powerUps.filter(p=>p.ttl>0);

        updateHUD();
      }
      draw();
      requestAnimationFrame(update);
    }

    function maybeLevelUp(){
      const newLevel=Math.floor(score/50)+1;
      if(newLevel>level){level=newLevel; speed=Math.min(20, speed+1); generateObstacles();}
    }

    function applyPowerUp(type){
      if(type==='score') score+=30;
      if(type==='slow') speed=Math.max(3, speed-2);
      if(type==='fast') speed=Math.min(22, speed+3);
      if(type==='ghost'){
        // temporary allow wrap/self-pass for a short time
        const oldWrap=wrapToggle.checked;
        wrapToggle.checked=true;
        setTimeout(()=>{wrapToggle.checked=oldWrap;},4000);
      }
    }

    function endGame(){
      gameOver=true; paused=true;
      if(score>bestScore){localStorage.setItem('snakepp_best',score);bestScore=score}
      updateHUD();
      drawGameOver();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // grid background subtle
      drawGrid();
      // food
      drawCell(food.x,food.y,()=>{
        ctx.fillStyle='rgba(255,99,71,0.9)'; ctx.beginPath(); ctx.arc((food.x+0.5)*grid,(food.y+0.5)*grid,grid*0.38,0,Math.PI*2); ctx.fill();
      });
      // powerups
      powerUps.forEach(p=>{
        drawCell(p.pos.x,p.pos.y,()=>{
          ctx.fillStyle='rgba(79,70,229,0.9)'; ctx.fillRect(p.pos.x*grid+grid*0.16,p.pos.y*grid+grid*0.16,grid*0.68,grid*0.68);
          ctx.fillStyle='white'; ctx.font=(grid*0.38)+'px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0].toUpperCase(), (p.pos.x+0.5)*grid, (p.pos.y+0.5)*grid);
        });
      });
      // obstacles
      obstacles.forEach(o=>drawCell(o.x,o.y,()=>{ctx.fillStyle='rgba(120,120,120,0.5)'; ctx.fillRect(o.x*grid+2,o.y*grid+2,grid-4,grid-4);}));
      // snake
      for(let i=snake.length-1;i>=0;i--){
        const s=snake[i];
        const t=i===0?0.95:0.6; // head brighter
        ctx.fillStyle=`rgba(16,185,129,${t})`;
        roundRect(ctx,s.x*grid+2,s.y*grid+2,grid-4,grid-4,4,true,false);
      }
    }

    function drawGrid(){
      ctx.save(); ctx.globalAlpha=0.06; ctx.strokeStyle='white'; ctx.lineWidth=1;
      for(let x=0;x<=cols;x++){ctx.beginPath();ctx.moveTo(x*grid,0);ctx.lineTo(x*grid,rows*grid);ctx.stroke()}
      for(let y=0;y<=rows;y++){ctx.beginPath();ctx.moveTo(0,y*grid);ctx.lineTo(cols*grid,y*grid);ctx.stroke()}
      ctx.restore();
    }

    function drawCell(x,y(fn){}){}

    function drawCell(x,y,fn){ ctx.save(); fn(); ctx.restore(); }

    function drawGameOver(){
      ctx.save(); ctx.fillStyle='rgba(2,6,12,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='white'; ctx.font='36px sans-serif'; ctx.textAlign='center'; ctx.fillText('Koniec gry', canvas.width/2, canvas.height/2-20);
      ctx.font='18px sans-serif'; ctx.fillText('Wynik: '+score, canvas.width/2, canvas.height/2+14);
      ctx.restore();
    }

    function updateHUD(){scoreEl.textContent=score;levelEl.textContent=level;speedEl.textContent=speed;lengthEl.textContent=snake.length;bestEl.textContent=bestScore}

    function roundRect(ctx,x,y,w,h,r,fill,stroke){if(typeof r==='undefined') r=5;ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath(); if(fill)ctx.fill(); if(stroke)ctx.stroke();}

    // input
    window.addEventListener('keydown',e=>{
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d'].includes(e.key)) e.preventDefault();
      if(e.key===' '){paused=!paused; if(!paused) requestAnimationFrame(update);}
      if(e.key==='ArrowUp' || e.key==='w') setDir(0,-1);
      if(e.key==='ArrowDown' || e.key==='s') setDir(0,1);
      if(e.key==='ArrowLeft' || e.key==='a') setDir(-1,0);
      if(e.key==='ArrowRight' || e.key==='d') setDir(1,0);
    });

    function setDir(x,y){ if((x!==-dir.x || y!==-dir.y)){dir={x,y}} }

    // touch controls (swipe)
    let touchStart=null;
    canvas.addEventListener('touchstart',e=>{const t=e.touches[0];touchStart={x:t.clientX,y:t.clientY}});
    canvas.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});
    canvas.addEventListener('touchend',e=>{
      if(!touchStart) return; const t=e.changedTouches[0]; const dx=t.clientX-touchStart.x; const dy=t.clientY-touchStart.y; if(Math.hypot(dx,dy)<30) {touchStart=null; return}
      if(Math.abs(dx)>Math.abs(dy)){ if(dx>0) setDir(1,0); else setDir(-1,0)} else { if(dy>0) setDir(0,1); else setDir(0,-1)} touchStart=null;
    });

    // buttons
    startBtn.addEventListener('click',()=>{paused=false; if(gameOver) resetState(); requestAnimationFrame(update)});
    pauseBtn.addEventListener('click',()=>{paused=!paused; if(!paused) requestAnimationFrame(update)});
    resetBtn.addEventListener('click',()=>{resetState(); requestAnimationFrame(update)});
    applyBtn.addEventListener('click',()=>{resetState(); requestAnimationFrame(update)});

    // download html
    downloadBtn.addEventListener('click',()=>{
      const blob=new Blob([document.documentElement.outerHTML],{type:'text/html'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='snakepp.html'; a.click(); URL.revokeObjectURL(url);
    });

    // helpers
    function init(){resetState(); requestAnimationFrame(update);}    

    // initial spawn of powerups over time
    setInterval(()=>{ if(!paused && !gameOver && Math.random()<0.6) spawnPowerUp() },4000);

    init();

  })();
  </script>
</body>
</html>
