<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake++ — gra w JavaScript (HTML5 canvas)</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#10b981;--muted:#94a3b8;--danger:#ef4444}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#020617 0%, #071027 60%);color:#e6eef6}
    .container{width:min(980px,95vw);display:grid;grid-template-columns:1fr 360px;gap:20px;padding:24px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}
    .game-area{display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas{background:linear-gradient(180deg,#071127, #02101a);border-radius:8px;box-shadow:inset 0 0 40px rgba(0,0,0,0.6);width:100%;height:auto}
    .hud{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:var(--accent);cursor:pointer}
    .btn.secondary{color:var(--muted)}
    .panel{padding:16px;display:flex;flex-direction:column;gap:12px}
    h1{margin:0;font-size:20px}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;text-align:center}
    .small{font-size:12px;color:var(--muted)}
    .controls{display:flex;flex-direction:column;gap:8px}
    .credit{font-size:12px;color:var(--muted);text-align:center}
    @media(max-width:880px){.container{grid-template-columns:1fr;}.panel{order:2}}
  </style>
</head>
<body>
  <div class="container">
    <div class="card game-area">
      <div style="width:100%">
        <h1>Snake++</h1>
        <p class="small">Sterowanie: strzałki / WASD / na urządzeniach: przesunięcie palcem. Spacja = pauza.</p>
      </div>

      <canvas id="gameCanvas" width="720" height="540"></canvas>

      <div class="hud">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="btn secondary">Pauza</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
        <div style="min-width:10px"></div>
        <div class="small">Wynik: <strong id="score">0</strong></div>
        <div class="small">Poziom: <strong id="level">1</strong></div>
        <div class="small">Prędkość: <strong id="speed">1</strong></div>
      </div>

      <div class="credit small">Stworzono przez ChatGPT — jeśli chcesz modyfikacje, powiedz które elementy zmienić.</div>
    </div>

    <aside class="card panel">
      <div>
        <strong>Informacje i power-upy</strong>
        <p class="small">Zbieraj jedzenie, unikaj przeszkód. Co kilka punktów pojawiają się power-upy: <em>+punkty</em>, <em>spowolnienie</em>, <em>przyspieszenie</em>, <em>przenikanie</em> (przejście przez ściany przez krótki czas).</p>
      </div>

      <div class="stats">
        <div class="stat">Długość: <div id="length">3</div></div>
        <div class="stat">Najlepszy: <div id="best">0</div></div>
      </div>

      <div class="controls">
        <label class="small">Ustawienia gry</label>
        <div style="display:flex;gap:8px">
          <label class="small">Siatka:</label>
          <select id="gridSize">
            <option value="20">20</option>
            <option value="24">24</option>
            <option value="28">28</option>
            <option value="32" selected>32</option>
          </select>
        </div>
        <div style="display:flex;gap:8px;align-items:center"><input id="wrapToggle" type="checkbox"><label class="small">Przejście przez ściany (wrap)</label></div>
        <div style="display:flex;gap:8px;align-items:center"><input id="obstaclesToggle" type="checkbox" checked><label class="small">Przeszkody</label></div>

        <div style="display:flex;gap:8px;margin-top:6px">
          <button id="applyBtn" class="btn secondary">Zastosuj</button>
          <button id="downloadBtn" class="btn">Pobierz .html</button>
        </div>
      </div>

      <div>
        <strong>Instrukcja</strong>
        <ol class="small">
          <li>Start — zaczyna grę.</li>
          <li>Pauza — zatrzymuje akcję (spacja też pauzuje).</li>
          <li>Reset — restart poziomu.</li>
          <li>Na urządzeniach dotykowych przesuń palcem, aby zmienić kierunek.</li>
        </ol>
      </div>
    </aside>
  </div>

  <script>
  // Poprawiona wersja Snake++
  (function(){
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // DOM
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const speedEl = document.getElementById('speed');
    const lengthEl = document.getElementById('length');
    const bestEl = document.getElementById('best');
    const gridSelect = document.getElementById('gridSize');
    const wrapToggle = document.getElementById('wrapToggle');
    const obstaclesToggle = document.getElementById('obstaclesToggle');
    const applyBtn = document.getElementById('applyBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    // game state
    let grid = parseInt(gridSelect.value, 10);
    let cols = Math.floor(canvas.width / grid);
    let rows = Math.floor(canvas.height / grid);

    let snake = [];
    let dir = {x:1,y:0};
    let nextDir = null;
    let food = null;
    let powerUps = [];
    let obstacles = [];
    let score = 0;
    let level = 1;
    let speed = 6; // moves per second
    let paused = true;
    let gameOver = false;
    let bestScore = parseInt(localStorage.getItem('snakepp_best') || '0', 10);

    // timing
    let lastTime = 0;
    let accum = 0;

    function resizeCanvasForDPR(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const displayWidth = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;
      canvas.width = Math.floor(displayWidth * dpr);
      canvas.height = Math.floor(displayHeight * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing operations to CSS pixels
      // recompute cols/rows based on CSS grid size (we use CSS pixels)
      cols = Math.floor(displayWidth / grid);
      rows = Math.floor(displayHeight / grid);
    }

    function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

    function randomEmptyCell(){
      for(let i=0;i<500;i++){
        const pos = {x: rand(0, cols-1), y: rand(0, rows-1)};
        if(!snake.some(s=>s.x===pos.x && s.y===pos.y) && !obstacles.some(o=>o.x===pos.x && o.y===pos.y)) return pos;
      }
      return {x:0,y:0};
    }

    function placeFood(){ food = randomEmptyCell(); }

    function generateObstacles(){
      obstacles = [];
      if(!obstaclesToggle.checked) return;
      const count = Math.floor((cols*rows)/120);
      for(let i=0;i<count;i++){ obstacles.push(randomEmptyCell()); }
    }

    function spawnPowerUp(){
      const types = ['score','slow','fast','ghost'];
      powerUps.push({ type: types[rand(0, types.length-1)], pos: randomEmptyCell(), ttl: 800 });
    }

    function resetState(){
      grid = parseInt(gridSelect.value,10);
      // ensure canvas CSS size is used to compute cols/rows
      resizeCanvasForDPR();
      snake = [ {x: Math.floor(cols/2), y: Math.floor(rows/2)}, {x: Math.floor(cols/2)-1, y: Math.floor(rows/2)}, {x: Math.floor(cols/2)-2, y: Math.floor(rows/2)} ];
      dir = {x:1,y:0}; nextDir = null;
      placeFood();
      powerUps = [];
      generateObstacles();
      score = 0; level = 1; speed = 6; paused = true; gameOver = false;
      bestScore = parseInt(localStorage.getItem('snakepp_best') || '0', 10);
      updateHUD();
      draw();
    }

    function setDir(x,y){
      // block direct reverse
      if(x === -dir.x && y === -dir.y) return;
      // queue next dir to avoid double-turns in one tick
      nextDir = {x,y};
    }

    function advanceTick(){
      if(nextDir){ dir = nextDir; nextDir = null; }
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
      const wrap = wrapToggle.checked;
      if(wrap){ head.x = (head.x + cols) % cols; head.y = (head.y + rows) % rows; }
      if(!wrap && (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows)) { endGame(); return; }
      if(snake.some((s,i)=>i>0 && s.x===head.x && s.y===head.y)) { endGame(); return; }
      if(obstacles.some(o=>o.x===head.x && o.y===head.y)) { endGame(); return; }

      snake.unshift(head);
      // eat food
      if(head.x === food.x && head.y === food.y){ score += 10; maybeLevelUp(); placeFood(); if(Math.random()<0.25) spawnPowerUp(); }
      else { snake.pop(); }

      // power-ups
      for(let i = 0; i < powerUps.length; i++){
        const p = powerUps[i];
        if(p.pos.x === head.x && p.pos.y === head.y){ applyPowerUp(p.type); powerUps.splice(i,1); break; }
      }
      powerUps.forEach(p=>p.ttl--);
      powerUps = powerUps.filter(p=>p.ttl>0);
      updateHUD();
    }

    function maybeLevelUp(){
      const newLevel = Math.floor(score/50)+1;
      if(newLevel > level){ level = newLevel; speed = Math.min(20, speed+1); generateObstacles(); }
    }

    function applyPowerUp(type){
      if(type === 'score') score += 30;
      if(type === 'slow') speed = Math.max(3, speed-2);
      if(type === 'fast') speed = Math.min(22, speed+3);
      if(type === 'ghost'){
        const oldWrap = wrapToggle.checked;
        wrapToggle.checked = true;
        setTimeout(()=>{ wrapToggle.checked = oldWrap; }, 4000);
      }
    }

    function endGame(){
      gameOver = true; paused = true;
      if(score > bestScore){ localStorage.setItem('snakepp_best', score); bestScore = score; }
      updateHUD(); drawGameOver();
    }

    function clear(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

    function draw(){
      clear();
      const displayWidth = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;
      // draw subtle grid
      ctx.save(); ctx.globalAlpha = 0.06; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
      for(let x = 0; x <= cols; x++){ ctx.beginPath(); ctx.moveTo(x*grid,0); ctx.lineTo(x*grid,rows*grid); ctx.stroke(); }
      for(let y = 0; y <= rows; y++){ ctx.beginPath(); ctx.moveTo(0,y*grid); ctx.lineTo(cols*grid,y*grid); ctx.stroke(); }
      ctx.restore();

      // food
      drawCell(food.x, food.y, ()=>{ ctx.fillStyle = 'rgba(255,99,71,0.95)'; ctx.beginPath(); ctx.arc((food.x+0.5)*grid, (food.y+0.5)*grid, grid*0.38, 0, Math.PI*2); ctx.fill(); });
      // powerUps
      powerUps.forEach(p=> drawCell(p.pos.x, p.pos.y, ()=>{ ctx.fillStyle='rgba(79,70,229,0.95)'; ctx.fillRect(p.pos.x*grid+grid*0.16, p.pos.y*grid+grid*0.16, grid*0.68, grid*0.68); ctx.fillStyle='white'; ctx.font=(grid*0.36)+'px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0].toUpperCase(), (p.pos.x+0.5)*grid, (p.pos.y+0.5)*grid); }));
      // obstacles
      obstacles.forEach(o=> drawCell(o.x, o.y, ()=>{ ctx.fillStyle='rgba(120,120,120,0.6)'; ctx.fillRect(o.x*grid+2, o.y*grid+2, grid-4, grid-4); }));
      // snake
      for(let i = snake.length - 1; i >= 0; i--){ const s = snake[i]; const t = (i===0)?0.98:0.65; ctx.fillStyle = `rgba(16,185,129,${t})`; roundRect(ctx, s.x*grid+2, s.y*grid+2, grid-4, grid-4, Math.max(3, grid*0.12), true, false); }
    }

    function drawCell(x,y,fn){ ctx.save(); fn(); ctx.restore(); }

    function drawGameOver(){ ctx.save(); ctx.fillStyle='rgba(2,6,12,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.font='36px sans-serif'; ctx.textAlign='center'; ctx.fillText('Koniec gry', canvas.clientWidth/2, canvas.clientHeight/2-20); ctx.font='18px sans-serif'; ctx.fillText('Wynik: '+score, canvas.clientWidth/2, canvas.clientHeight/2+14); ctx.restore(); }

    function updateHUD(){ scoreEl.textContent = score; levelEl.textContent = level; speedEl.textContent = speed; lengthEl.textContent = snake.length; bestEl.textContent = bestScore; }

    function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(typeof r==='undefined') r=5; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

    // game loop using time accumulator
    function gameLoop(timestamp){
      if(!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime; lastTime = timestamp;
      if(!paused && !gameOver){
        accum += delta;
        const msPerMove = 1000 / speed;
        while(accum >= msPerMove){ advanceTick(); accum -= msPerMove; }
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    // input
    window.addEventListener('keydown', e=>{
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d'].includes(e.key)) e.preventDefault();
      if(e.key === ' '){ paused = !paused; if(!paused) requestAnimationFrame(gameLoop); }
      if(e.key === 'ArrowUp' || e.key === 'w') setDir(0,-1);
      if(e.key === 'ArrowDown' || e.key === 's') setDir(0,1);
      if(e.key === 'ArrowLeft' || e.key === 'a') setDir(-1,0);
      if(e.key === 'ArrowRight' || e.key === 'd') setDir(1,0);
    });

    // touch (swipe)
    let touchStart = null;
    canvas.addEventListener('touchstart', e=>{ const t = e.touches[0]; touchStart = {x: t.clientX, y: t.clientY}; });
    canvas.addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});
    canvas.addEventListener('touchend', e=>{
      if(!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y; touchStart = null; if(Math.hypot(dx,dy) < 20) return;
      if(Math.abs(dx) > Math.abs(dy)){ if(dx > 0) setDir(1,0); else setDir(-1,0); } else { if(dy > 0) setDir(0,1); else setDir(0,-1); }
    });

    // buttons
    startBtn.addEventListener('click', ()=>{ if(gameOver) resetState(); paused = false; requestAnimationFrame(gameLoop); });
    pauseBtn.addEventListener('click', ()=>{ paused = !paused; if(!paused) requestAnimationFrame(gameLoop); });
    resetBtn.addEventListener('click', ()=>{ resetState(); });
    applyBtn.addEventListener('click', ()=>{ resetState(); });

    downloadBtn.addEventListener('click', ()=>{
      const blob = new Blob([document.documentElement.outerHTML], {type:'text/html'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'snakepp.html'; a.click(); URL.revokeObjectURL(url);
    });

    // window resize handling
    window.addEventListener('resize', ()=>{ resizeCanvasForDPR(); draw(); });

    // spawn powerups occasionally
    setInterval(()=>{ if(!paused && !gameOver && Math.random() < 0.6) spawnPowerUp(); }, 4000);

    // init
    resizeCanvasForDPR(); resetState(); requestAnimationFrame(gameLoop);

  })();
  </script>
</body>
</html>

  
